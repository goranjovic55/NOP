# Vulnerability Scan Analysis & Required Fixes

## Current State Assessment (2026-01-01)

### ‚úÖ What EXISTS:
1. **Database Model** (`backend/app/models/vulnerability.py`):
   - Complete `Vulnerability` model with CVE, CVSS, port, service, version tracking
   - Links vulnerabilities to specific assets (host IP)
   - Tracks discovery method, confidence, proof-of-concept
   - Status tracking (NEW, CONFIRMED, FALSE_POSITIVE, etc.)

2. **Backend Scanner Service** (`backend/app/services/scanner.py`):
   - `vulnerability_scan(host: str)` method using `nmap --script vuln`
   - Returns Nmap XML output (needs parsing into DB)

3. **Frontend UI** (`frontend/src/pages/Scans.tsx`):
   - Vulnerability scan button and results display
   - CVE/CVSS/severity/port/service display per vulnerability
   - "Build Exploit" button linking to Exploit page
   - Database selection (CVE, Exploit-DB, Metasploit, Vulners, PacketStorm)

4. **Exploit Page** (`frontend/src/pages/Exploit.tsx`):
   - Receives vulnerability data via navigation state
   - Shows CVE ID and CVSS score when exploiting
   - Generates reverse shells, web shells, meterpreter payloads

---

## ‚ùå Critical Issues Identified:

### 1. **MOCK DATA ONLY - No Real Scans**
**File**: `frontend/src/pages/Scans.tsx` Line 245-377

```typescript
const handleVulnerabilityScan = async (tabId: string) => {
  // ...gets ports from asset
  // Simulate vulnerability scanning delay
  await new Promise(resolve => setTimeout(resolve, 2000));
  
  const mockVulnerabilities: Vulnerability[] = [];
  
  // Hardcoded vulnerabilities based on port number
  if (portsToScan.includes(22)) {
    mockVulnerabilities.push({
      id: 'vuln-1',
      cve_id: 'CVE-2023-5678',  // FAKE CVE
      title: 'OpenSSH Remote Code Execution',  // FAKE
      // ... all hardcoded
    });
  }
```

**Problem**: Frontend creates fake vulnerabilities based on port numbers alone, **not actual service versions**.

---

### 2. **No Service Version Detection**
**Missing**: Integration between port scan and version detection

Current flow:
1. Port scan finds open ports ‚Üí stored in `asset.open_ports`
2. Vulnerability scan reads ports ‚Üí **assumes** services based on port number
3. **NO version detection** (e.g., "OpenSSH 7.4" vs "OpenSSH 9.0")

**Required**: 
- Backend endpoint: `/api/v1/scans/{asset_id}/service-detection`
- Uses `nmap -sV` to detect actual versions
- Stores results in `vulnerability.version` field

---

### 3. **No Real CVE Database Lookup**
**Missing**: API endpoints to query CVE databases

Current databases shown in UI:
- CVE (National Vulnerability Database)
- Exploit-DB
- Metasploit Framework
- Vulners API
- PacketStorm Security

**Required endpoints**:
```
POST /api/v1/scans/{asset_id}/vulnerability-scan
{
  "ports": [22, 80, 3306],
  "databases": ["cve", "exploit_db", "metasploit"],
  "service_versions": {
    "22": {"service": "ssh", "version": "OpenSSH 7.4"},
    "80": {"service": "http", "version": "Apache 2.4.6"},
    "3306": {"service": "mysql", "version": "5.7.42"}
  }
}

Response:
{
  "vulnerabilities": [
    {
      "cve_id": "CVE-2018-15473",  // REAL CVE
      "title": "OpenSSH Username Enumeration",
      "cvss_score": 5.3,
      "affected_service": "ssh",
      "affected_port": 22,
      "affected_version": "OpenSSH 7.4",
      "exploit_available": true,
      "exploit_modules": [
        {
          "framework": "metasploit",
          "module": "auxiliary/scanner/ssh/ssh_enumusers",
          "description": "SSH Username Enumeration"
        }
      ],
      "source": "cve"
    }
  ]
}
```

---

### 4. **No Exploit Module Selection**
**Current behavior**: 
- User clicks "Build Exploit" on a vulnerability
- Goes to generic exploit builder with manual payload creation
- **No pre-configured exploit modules** based on CVE

**Required**:
1. When vulnerability has `exploit_available: true`, show list of modules:
   - Metasploit modules (e.g., `exploit/linux/ssh/openssh_x11_forwarding`)
   - Manual exploit scripts (from Exploit-DB)
   - Custom NOP platform modules

2. User selects exploit module ‚Üí auto-configures:
   - Target IP (from vulnerability.asset.ip_address)
   - Target port (from vulnerability.port)
   - Payload options (LHOST, LPORT)
   - Required parameters (e.g., username for SSH exploits)

---

## üîß Implementation Roadmap

### Phase 1: Service Version Detection (CRITICAL)
**Backend**:
```python
# backend/app/api/v1/endpoints/scans.py

@router.post("/{asset_id}/service-detection")
async def detect_services(
    asset_id: UUID,
    ports: List[int],
    db: AsyncSession = Depends(get_db)
):
    """Run nmap -sV on specified ports to detect service versions"""
    asset = await db.get(Asset, asset_id)
    if not asset:
        raise HTTPException(404, "Asset not found")
    
    # Run nmap -sV -p22,80,3306 <target_ip>
    scanner = ScannerService()
    results = await scanner.service_detection(asset.ip_address, ports)
    
    # Parse and return service versions
    return {
        "asset_id": asset_id,
        "services": results  # {"22": {"service": "ssh", "version": "OpenSSH 7.4"}}
    }
```

**Frontend**:
```typescript
// After port scan completes, automatically detect versions
const detectVersions = async (assetId: string, ports: number[]) => {
  const response = await fetch(`/api/v1/scans/${assetId}/service-detection`, {
    method: 'POST',
    body: JSON.stringify({ ports })
  });
  const data = await response.json();
  // Store versions for vulnerability lookup
  setServiceVersions(data.services);
};
```

---

### Phase 2: Real CVE Lookup
**Backend**:
```python
# backend/app/services/vulnerability_scanner.py

class VulnerabilityScanner:
    async def scan_for_cves(
        self,
        asset_id: UUID,
        services: Dict[str, Dict[str, str]],  # port -> {service, version}
        databases: List[str]
    ) -> List[Vulnerability]:
        """Query CVE databases for matching vulnerabilities"""
        
        vulnerabilities = []
        
        for port, info in services.items():
            service = info['service']
            version = info['version']
            
            # Query CVE database
            if 'cve' in databases:
                cves = await self._query_cve_database(service, version)
                vulnerabilities.extend(cves)
            
            # Query Exploit-DB
            if 'exploit_db' in databases:
                exploits = await self._query_exploitdb(service, version)
                vulnerabilities.extend(exploits)
            
            # Check Metasploit modules
            if 'metasploit' in databases:
                modules = await self._query_metasploit(service, version)
                vulnerabilities.extend(modules)
        
        # Store in database
        for vuln_data in vulnerabilities:
            vuln = Vulnerability(
                asset_id=asset_id,
                cve_id=vuln_data['cve_id'],
                title=vuln_data['title'],
                cvss_score=vuln_data['cvss_score'],
                service=vuln_data['service'],
                port=str(vuln_data['port']),
                version=vuln_data['version'],
                severity=self._cvss_to_severity(vuln_data['cvss_score']),
                discovered_by='nmap_vuln_scan'
            )
            self.db.add(vuln)
        
        await self.db.commit()
        return vulnerabilities
```

---

### Phase 3: Exploit Module Library
**Database schema addition**:
```python
# backend/app/models/exploit_module.py

class ExploitModule(Base):
    __tablename__ = "exploit_modules"
    
    id = Column(UUID, primary_key=True, default=uuid.uuid4)
    vulnerability_id = Column(UUID, ForeignKey("vulnerabilities.id"))
    
    # Module identification
    framework = Column(String)  # 'metasploit', 'exploitdb', 'custom'
    module_path = Column(String)  # 'exploit/linux/ssh/openssh_x11'
    name = Column(String)
    description = Column(Text)
    
    # Requirements
    required_params = Column(JSON)  # ["USERNAME", "PASSWORD"]
    optional_params = Column(JSON)
    
    # Payload compatibility
    supported_payloads = Column(JSON)  # ["cmd/unix/reverse", "cmd/unix/bind"]
    default_payload = Column(String)
    
    # Reliability
    reliability = Column(Float)  # 0.0 - 1.0
    stability = Column(String)  # 'stable', 'unstable', 'crash'
```

**API endpoint**:
```python
@router.get("/vulnerabilities/{vuln_id}/exploits")
async def get_exploit_modules(vuln_id: UUID):
    """Get available exploit modules for a vulnerability"""
    modules = await db.execute(
        select(ExploitModule).where(ExploitModule.vulnerability_id == vuln_id)
    )
    return modules.scalars().all()
```

**Frontend integration**:
```typescript
// When "Build Exploit" clicked, show module selector first
const selectExploitModule = async (vulnerability: Vulnerability) => {
  const response = await fetch(`/api/v1/vulnerabilities/${vulnerability.id}/exploits`);
  const modules = await response.json();
  
  // Show modal: "Select Exploit Module"
  // - List all modules with descriptions
  // - User picks one
  // - Auto-populate exploit builder with module settings
};
```

---

## üéØ Summary of Required Changes

### Backend (`backend/app/`):
1. **NEW**: `api/v1/endpoints/vulnerabilities.py` - vulnerability scan endpoint
2. **NEW**: `services/vulnerability_scanner.py` - CVE database integration
3. **NEW**: `models/exploit_module.py` - exploit module database
4. **UPDATE**: `services/scanner.py` - enhance service detection parsing
5. **UPDATE**: `api/v1/endpoints/scans.py` - add service detection endpoint

### Frontend (`frontend/src/`):
1. **UPDATE**: `pages/Scans.tsx`:
   - Replace mock data with real API call
   - Add service version detection step
   - Show "detecting versions..." progress

2. **UPDATE**: `pages/Exploit.tsx`:
   - Add exploit module selection modal
   - Pre-configure target/port from vulnerability
   - Show module requirements

3. **NEW**: `components/ExploitModuleSelector.tsx`:
   - List available modules
   - Show reliability/stability
   - Configure module parameters

### Database:
1. **NEW TABLE**: `exploit_modules` - pre-configured exploits
2. **POPULATE**: Seed common Metasploit modules
3. **UPDATE**: Ensure `vulnerabilities` table links to assets correctly

---

## üìä Current Workflow vs Required Workflow

### ‚ùå CURRENT (Broken):
```
1. Port Scan ‚Üí finds ports [22, 80, 3306]
2. Vuln Scan ‚Üí ASSUMES OpenSSH on 22 (WRONG!)
3. Shows FAKE "CVE-2023-5678" 
4. User clicks "Build Exploit" ‚Üí Generic payload builder
5. Manual exploitation (no module guidance)
```

### ‚úÖ REQUIRED:
```
1. Port Scan ‚Üí finds ports [22, 80, 3306]
2. Service Detection ‚Üí "OpenSSH 7.4", "Apache 2.4.6", "MySQL 5.7.42"
3. CVE Lookup ‚Üí Queries real databases for those exact versions
4. Returns REAL CVEs: "CVE-2018-15473" with CVSS 5.3
5. Shows "3 exploit modules available"
6. User selects: "Metasploit: auxiliary/scanner/ssh/ssh_enumusers"
7. Auto-fills target IP, port, required params
8. Execute ‚Üí Real exploitation attempt
```

---

## üö® Security Considerations

1. **Rate Limiting**: CVE API queries should be rate-limited to avoid bans
2. **Caching**: Cache CVE lookup results (version + service ‚Üí CVEs)
3. **Validation**: Always validate target IP belongs to scanned asset
4. **Logging**: Log all exploitation attempts with timestamps
5. **Consent**: Warn users before executing exploits (legal liability)

---

## üìù Next Steps

1. **IMMEDIATE**: Implement service version detection (`nmap -sV` integration)
2. **CRITICAL**: Replace mock vulnerability data with real CVE lookups
3. **HIGH**: Build exploit module database and selector UI
4. **MEDIUM**: Add CVE database API integrations (NVD, Exploit-DB)
5. **LOW**: Enhanced exploit logging and session management

---

## Testing Checklist

- [ ] Port scan on 172.21.0.69 (SSH test server) detects OpenSSH version
- [ ] Vulnerability scan finds REAL CVEs for detected SSH version
- [ ] CVE links to Metasploit module (if available)
- [ ] "Build Exploit" pre-fills target IP/port from scan results
- [ ] Exploit execution targets correct host (not random)
- [ ] Vulnerability database stores scan results persistently
- [ ] Re-scanning same host updates existing vulnerabilities
