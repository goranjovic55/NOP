"""
Unit and integration tests for CVE-to-Exploit Matching
"""

import pytest
import json
from pathlib import Path


@pytest.fixture
def exploit_mappings():
    """Load CVE-to-exploit mappings"""
    mappings_path = Path(__file__).parent.parent / "app" / "data" / "cve_to_exploits.json"
    with open(mappings_path, 'r') as f:
        return json.load(f)


class TestExploitMappings:
    """Test CVE-to-exploit mapping data quality"""
    
    def test_mappings_file_exists(self):
        """Test exploit mappings file exists"""
        mappings_path = Path(__file__).parent.parent / "app" / "data" / "cve_to_exploits.json"
        assert mappings_path.exists()
    
    def test_mappings_valid_json(self, exploit_mappings):
        """Test mappings are valid JSON"""
        assert isinstance(exploit_mappings, dict)
        assert len(exploit_mappings) > 0
    
    def test_has_minimum_50_cves(self, exploit_mappings):
        """Test at least 50 real CVEs mapped"""
        assert len(exploit_mappings) >= 50, f"Only {len(exploit_mappings)} CVEs mapped, need at least 50"
    
    def test_real_cve_ids(self, exploit_mappings):
        """Test CVE IDs follow proper format"""
        # Real CVEs should match CVE-YYYY-NNNNN format
        import re
        cve_pattern = re.compile(r'^CVE-\d{4}-\d{4,7}$')
        
        for cve_id in exploit_mappings.keys():
            assert cve_pattern.match(cve_id), f"Invalid CVE ID format: {cve_id}"
    
    def test_no_fake_cve_ids(self, exploit_mappings):
        """Test no fake CVE IDs (CVE-2023-XXXX, CVE-2023-9999, etc)"""
        fake_patterns = [
            "CVE-2023-XXXX",
            "CVE-2023-9999",
            "CVE-2023-1234",
            "CVE-2023-5678",
            "CVE-2023-9101",
            "CVE-2023-21980"
        ]
        
        for cve_id in exploit_mappings.keys():
            assert cve_id not in fake_patterns, f"Fake CVE ID found: {cve_id}"
    
    def test_eternalblue_mapping_exists(self, exploit_mappings):
        """Test EternalBlue (CVE-2017-0144) is mapped"""
        assert "CVE-2017-0144" in exploit_mappings
        
        eternalblue = exploit_mappings["CVE-2017-0144"]
        assert len(eternalblue) > 0
        assert eternalblue[0]["platform"] == "metasploit"
        assert "eternalblue" in eternalblue[0]["module_path"].lower()
    
    def test_heartbleed_mapping_exists(self, exploit_mappings):
        """Test Heartbleed (CVE-2014-0160) is mapped"""
        assert "CVE-2014-0160" in exploit_mappings
        
        heartbleed = exploit_mappings["CVE-2014-0160"]
        assert len(heartbleed) > 0
        assert "heartbleed" in heartbleed[0]["title"].lower()
    
    def test_log4shell_mapping_exists(self, exploit_mappings):
        """Test Log4Shell (CVE-2021-44228) is mapped"""
        assert "CVE-2021-44228" in exploit_mappings
        
        log4shell = exploit_mappings["CVE-2021-44228"]
        assert len(log4shell) > 0
        assert "log4" in log4shell[0]["title"].lower()
    
    def test_shellshock_mapping_exists(self, exploit_mappings):
        """Test Shellshock (CVE-2014-6271) is mapped"""
        assert "CVE-2014-6271" in exploit_mappings
        
        shellshock = exploit_mappings["CVE-2014-6271"]
        assert len(shellshock) > 0
        assert "bash" in shellshock[0]["title"].lower() or "shellshock" in shellshock[0]["title"].lower()
    
    def test_struts_mapping_exists(self, exploit_mappings):
        """Test Apache Struts (CVE-2017-5638) is mapped"""
        assert "CVE-2017-5638" in exploit_mappings
        
        struts = exploit_mappings["CVE-2017-5638"]
        assert len(struts) > 0
        assert "struts" in struts[0]["title"].lower()


class TestExploitDataStructure:
    """Test exploit entry data structure"""
    
    def test_all_exploits_have_required_fields(self, exploit_mappings):
        """Test all exploit entries have required fields"""
        required_fields = [
            "platform",
            "title",
            "description",
            "exploit_type",
            "target_platform",
            "rank",
            "verified"
        ]
        
        for cve_id, exploits in exploit_mappings.items():
            for exploit in exploits:
                for field in required_fields:
                    assert field in exploit, f"{cve_id} exploit missing field: {field}"
    
    def test_platform_values_valid(self, exploit_mappings):
        """Test platform field has valid values"""
        valid_platforms = ["metasploit", "exploit-db", "github", "packetstorm"]
        
        for cve_id, exploits in exploit_mappings.items():
            for exploit in exploits:
                assert exploit["platform"] in valid_platforms, \
                    f"{cve_id} has invalid platform: {exploit['platform']}"
    
    def test_rank_values_valid(self, exploit_mappings):
        """Test rank field has valid Metasploit ranks"""
        valid_ranks = ["manual", "low", "average", "normal", "good", "great", "excellent"]
        
        for cve_id, exploits in exploit_mappings.items():
            for exploit in exploits:
                assert exploit["rank"] in valid_ranks, \
                    f"{cve_id} has invalid rank: {exploit['rank']}"
    
    def test_verified_is_boolean(self, exploit_mappings):
        """Test verified field is boolean"""
        for cve_id, exploits in exploit_mappings.items():
            for exploit in exploits:
                assert isinstance(exploit["verified"], bool), \
                    f"{cve_id} verified field is not boolean"
    
    def test_metasploit_modules_have_paths(self, exploit_mappings):
        """Test Metasploit exploits have module paths"""
        for cve_id, exploits in exploit_mappings.items():
            for exploit in exploits:
                if exploit["platform"] == "metasploit":
                    assert exploit.get("module_path"), \
                        f"{cve_id} Metasploit exploit missing module_path"
                    assert "/" in exploit["module_path"], \
                        f"{cve_id} module_path should be path format"
    
    def test_exploit_db_entries_have_ids(self, exploit_mappings):
        """Test Exploit-DB entries have exploit_db_id"""
        for cve_id, exploits in exploit_mappings.items():
            for exploit in exploits:
                if exploit["platform"] == "exploit-db":
                    assert exploit.get("exploit_db_id") is not None, \
                        f"{cve_id} Exploit-DB entry missing exploit_db_id"
    
    def test_target_platforms_valid(self, exploit_mappings):
        """Test target_platform has reasonable values"""
        valid_platforms = [
            "windows", "linux", "unix", "java", "php", "ruby",
            "cisco", "fortinet", "multiple", "osx", None
        ]
        
        for cve_id, exploits in exploit_mappings.items():
            for exploit in exploits:
                platform = exploit.get("target_platform")
                assert platform in valid_platforms, \
                    f"{cve_id} has unexpected target_platform: {platform}"


class TestExploitMatching:
    """Test exploit matching logic"""
    
    def test_find_exploits_by_cve_id(self, exploit_mappings):
        """Test finding exploits by CVE ID"""
        cve_id = "CVE-2017-0144"
        exploits = exploit_mappings.get(cve_id, [])
        
        assert len(exploits) > 0
        assert all(e["platform"] for e in exploits)
    
    def test_multiple_exploits_per_cve(self, exploit_mappings):
        """Test CVEs can have multiple exploit options"""
        # Some CVEs should have multiple exploit options
        multi_exploit_cves = [cve for cve, exploits in exploit_mappings.items() if len(exploits) > 1]
        
        # Not all CVEs need multiple, but at least some should
        assert len(multi_exploit_cves) >= 0  # Optional: some CVEs may have alternatives
    
    def test_exploit_ranking_for_selection(self, exploit_mappings):
        """Test exploits can be ranked for best selection"""
        rank_order = ["excellent", "great", "good", "normal", "average", "low", "manual"]
        
        # Function to get best exploit
        def get_best_exploit(exploits):
            return max(exploits, key=lambda e: rank_order.index(e["rank"]) if e["rank"] in rank_order else 999)
        
        # Test with EternalBlue
        eternalblue = exploit_mappings.get("CVE-2017-0144", [])
        if eternalblue:
            best = get_best_exploit(eternalblue)
            assert best["rank"] == "excellent"
    
    def test_verified_exploits_preferred(self, exploit_mappings):
        """Test verified exploits can be filtered"""
        for cve_id, exploits in exploit_mappings.items():
            verified = [e for e in exploits if e["verified"]]
            
            # At least one exploit per CVE should be verified
            assert len(verified) > 0, f"{cve_id} has no verified exploits"


class TestKnownVulnerabilities:
    """Test mappings for well-known vulnerabilities"""
    
    def test_bluekeep_mapped(self, exploit_mappings):
        """Test BlueKeep (CVE-2019-0708) is mapped"""
        assert "CVE-2019-0708" in exploit_mappings
    
    def test_zerologon_mapped(self, exploit_mappings):
        """Test Zerologon (CVE-2020-1472) is mapped"""
        assert "CVE-2020-1472" in exploit_mappings
    
    def test_samba_cry_mapped(self, exploit_mappings):
        """Test SambaCry (CVE-2017-7494) is mapped"""
        assert "CVE-2017-7494" in exploit_mappings
    
    def test_dirty_cow_mapped(self, exploit_mappings):
        """Test Dirty COW (CVE-2016-5195) is mapped"""
        assert "CVE-2016-5195" in exploit_mappings
    
    def test_drupalgeddon_mapped(self, exploit_mappings):
        """Test Drupalgeddon (CVE-2018-7600) is mapped"""
        assert "CVE-2018-7600" in exploit_mappings


class TestExploitReferences:
    """Test exploit references and documentation"""
    
    def test_metasploit_modules_have_references(self, exploit_mappings):
        """Test Metasploit modules have reference URLs"""
        metasploit_count = 0
        with_refs = 0
        
        for cve_id, exploits in exploit_mappings.items():
            for exploit in exploits:
                if exploit["platform"] == "metasploit":
                    metasploit_count += 1
                    if exploit.get("reference_url"):
                        with_refs += 1
        
        # At least 80% of Metasploit modules should have reference URLs
        if metasploit_count > 0:
            ref_percentage = (with_refs / metasploit_count) * 100
            assert ref_percentage >= 80, \
                f"Only {ref_percentage:.1f}% of Metasploit modules have reference URLs"
    
    def test_exploit_db_ids_unique(self, exploit_mappings):
        """Test Exploit-DB IDs are unique"""
        exploit_db_ids = []
        
        for cve_id, exploits in exploit_mappings.items():
            for exploit in exploits:
                edb_id = exploit.get("exploit_db_id")
                if edb_id:
                    assert edb_id not in exploit_db_ids, \
                        f"Duplicate Exploit-DB ID: {edb_id}"
                    exploit_db_ids.append(edb_id)
    
    def test_descriptions_not_empty(self, exploit_mappings):
        """Test all exploits have non-empty descriptions"""
        for cve_id, exploits in exploit_mappings.items():
            for exploit in exploits:
                desc = exploit.get("description", "")
                assert len(desc) > 0, f"{cve_id} has empty description"
                assert len(desc) > 20, f"{cve_id} description too short: {desc}"


class TestExploitUsability:
    """Test exploit data is usable for practical exploitation"""
    
    def test_can_build_metasploit_command(self, exploit_mappings):
        """Test Metasploit module paths can build commands"""
        eternalblue = exploit_mappings["CVE-2017-0144"][0]
        
        module_path = eternalblue["module_path"]
        
        # Should be able to construct: use exploit/windows/smb/ms17_010_eternalblue
        command = f"use {module_path}"
        
        assert "use exploit/" in command or "use auxiliary/" in command
    
    def test_can_lookup_exploit_db(self, exploit_mappings):
        """Test Exploit-DB IDs can construct URLs"""
        # Find an Exploit-DB entry
        for cve_id, exploits in exploit_mappings.items():
            for exploit in exploits:
                if exploit.get("exploit_db_id"):
                    edb_id = exploit["exploit_db_id"]
                    url = f"https://www.exploit-db.com/exploits/{edb_id}"
                    
                    assert "exploit-db.com" in url
                    assert str(edb_id) in url
                    return  # Test passed
    
    def test_target_platform_guides_usage(self, exploit_mappings):
        """Test target platform helps select appropriate exploit"""
        # Windows-specific CVE should have Windows exploit
        eternalblue = exploit_mappings["CVE-2017-0144"][0]
        assert eternalblue["target_platform"] == "windows"
        
        # Linux-specific CVE should have Linux/Unix exploit
        dirty_cow = exploit_mappings.get("CVE-2016-5195")
        if dirty_cow:
            assert dirty_cow[0]["target_platform"] in ["unix", "linux"]
