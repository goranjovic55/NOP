"""
Exploit shell WebSocket handler
"""

from fastapi import APIRouter, WebSocket, WebSocketDisconnect
import asyncio
import socket
import logging
import json

logger = logging.getLogger(__name__)

router = APIRouter()

@router.websocket("/shell/{target_ip}/{target_port}")
async def exploit_shell_websocket(websocket: WebSocket, target_ip: str, target_port: int):
    """
    WebSocket endpoint for handling raw TCP shell connections (bind/reverse shells).
    Connects to the target IP:Port and pipes data between WebSocket and TCP socket.
    """
    logger.info(f"WebSocket connection attempt: {target_ip}:{target_port}")
    try:
        await websocket.accept()
        logger.info(f"WebSocket accepted: {target_ip}:{target_port}")
    except Exception as e:
        logger.error(f"WebSocket accept failed: {e}")
        return

    logger.info(f"WebSocket connected for shell session: {target_ip}:{target_port}")
    
    tcp_socket = None
    
    try:
        # 1. Connect to the target TCP port (Bind Shell)
        # Note: For reverse shells, we would need to listen, but for now we assume bind shell
        # as per the vsftpd 2.3.4 exploit (port 6200)
        
        tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        tcp_socket.settimeout(10) # 10 second connection timeout
        
        await websocket.send_text(json.dumps({
            "type": "status",
            "status": "connecting",
            "message": f"Connecting to {target_ip}:{target_port}..."
        }))
        
        # Run blocking connect in thread pool
        loop = asyncio.get_event_loop()
        await loop.run_in_executor(None, tcp_socket.connect, (target_ip, target_port))
        
        tcp_socket.setblocking(False)
        
        await websocket.send_text(json.dumps({
            "type": "status",
            "status": "connected",
            "message": f"Connected to {target_ip}:{target_port}"
        }))
        
        # 2. Pipe data loops
        
        async def receive_from_tcp():
            """Read from TCP socket and send to WebSocket"""
            while True:
                try:
                    data = await loop.sock_recv(tcp_socket, 4096)
                    if not data:
                        break
                    # Send raw output to frontend
                    await websocket.send_text(json.dumps({
                        "type": "output",
                        "data": data.decode('utf-8', errors='replace')
                    }))
                except Exception as e:
                    logger.error(f"Error receiving from TCP: {e}")
                    break
            
            await websocket.send_text(json.dumps({
                "type": "status",
                "status": "disconnected",
                "message": "Remote host closed connection"
            }))

        async def receive_from_websocket():
            """Read from WebSocket and send to TCP socket"""
            while True:
                try:
                    message = await websocket.receive_text()
                    # Frontend sends raw command string
                    if message:
                        # Ensure newline for commands
                        if not message.endswith('\n'):
                            message += '\n'
                        await loop.sock_sendall(tcp_socket, message.encode('utf-8'))
                except WebSocketDisconnect:
                    break
                except Exception as e:
                    logger.error(f"Error receiving from WebSocket: {e}")
                    break

        # Run both loops concurrently
        receiver_task = asyncio.create_task(receive_from_tcp())
        sender_task = asyncio.create_task(receive_from_websocket())
        
        done, pending = await asyncio.wait(
            [receiver_task, sender_task],
            return_when=asyncio.FIRST_COMPLETED
        )
        
        for task in pending:
            task.cancel()
            
    except Exception as e:
        logger.error(f"Shell connection error: {e}")
        await websocket.send_text(json.dumps({
            "type": "error",
            "message": f"Connection failed: {str(e)}"
        }))
        
    finally:
        if tcp_socket:
            tcp_socket.close()
        try:
            await websocket.close()
        except:
            pass
        logger.info(f"Shell session ended: {target_ip}:{target_port}")
