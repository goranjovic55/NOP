"""
Exploit-DB Service for dynamic exploit lookups using searchsploit
"""

import json
import logging
import subprocess
import asyncio
from typing import Dict, Any, List, Optional
from functools import lru_cache

logger = logging.getLogger(__name__)


class ExploitDBService:
    """Service for querying Exploit-DB using searchsploit"""
    
    def __init__(self):
        self._searchsploit_available: Optional[bool] = None
    
    async def is_available(self) -> bool:
        """Check if searchsploit is available in the system"""
        if self._searchsploit_available is not None:
            return self._searchsploit_available
        
        try:
            # Run searchsploit with a simple search to check availability
            # Note: --help returns exit code 2, so we use a simple query instead
            process = await asyncio.create_subprocess_exec(
                'searchsploit', '--cve', 'CVE-2000-0001', '--json',
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            stdout, stderr = await process.communicate()
            
            # Check if we got valid JSON output (even if no results)
            try:
                json.loads(stdout.decode())
                self._searchsploit_available = True
                logger.info("searchsploit is available")
            except json.JSONDecodeError:
                logger.warning("searchsploit found but returned invalid JSON")
                self._searchsploit_available = False
            
        except FileNotFoundError:
            logger.warning("searchsploit not found in PATH")
            self._searchsploit_available = False
        except Exception as e:
            logger.error(f"Error checking searchsploit availability: {str(e)}")
            self._searchsploit_available = False
        
        return self._searchsploit_available
    
    async def search_by_cve(self, cve_id: str) -> List[Dict[str, Any]]:
        """
        Search for exploits by CVE ID using searchsploit
        
        Args:
            cve_id: CVE identifier (e.g., CVE-2023-1234)
            
        Returns:
            List of exploit dicts with standardized format
        """
        # Check if searchsploit is available
        if not await self.is_available():
            logger.debug(f"searchsploit not available, skipping lookup for {cve_id}")
            return []
        
        try:
            # Run searchsploit with JSON output
            process = await asyncio.create_subprocess_exec(
                'searchsploit', '--cve', cve_id, '--json',
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate()
            
            if process.returncode != 0:
                logger.warning(f"searchsploit returned error for {cve_id}: {stderr.decode()}")
                return []
            
            # Parse JSON output
            try:
                result = json.loads(stdout.decode())
                exploits = self._parse_searchsploit_results(cve_id, result)
                logger.info(f"Found {len(exploits)} exploits for {cve_id} via searchsploit")
                return exploits
                
            except json.JSONDecodeError as e:
                logger.error(f"Failed to parse searchsploit JSON output: {str(e)}")
                return []
        
        except Exception as e:
            logger.error(f"Error searching Exploit-DB for {cve_id}: {str(e)}")
            return []
    
    def _parse_searchsploit_results(self, cve_id: str, result: Dict) -> List[Dict[str, Any]]:
        """
        Parse searchsploit JSON results into standardized format
        
        Args:
            cve_id: CVE identifier
            result: Raw searchsploit JSON result
            
        Returns:
            List of standardized exploit dicts
        """
        exploits = []
        
        # searchsploit JSON format:
        # {
        #   "RESULTS_EXPLOIT": [
        #     {
        #       "Title": "...",
        #       "EDB-ID": "12345",
        #       "Type": "remote|local|webapps|...",
        #       "Platform": "linux|windows|...",
        #       "Path": "/path/to/exploit.txt",
        #       "Codes": "CVE-2014-6271;..."
        #     }
        #   ],
        #   "RESULTS_SHELLCODE": [...]
        # }
        
        for exploit_list_key in ['RESULTS_EXPLOIT', 'RESULTS_SHELLCODE']:
            if exploit_list_key not in result:
                continue
            
            for item in result[exploit_list_key]:
                try:
                    # Extract Exploit-DB ID
                    edb_id = item.get('EDB-ID', '')
                    
                    # Build standardized exploit dict
                    exploit = {
                        'id': f'edb-{edb_id}',
                        'cve_id': cve_id,
                        'platform': 'exploitdb',
                        'module_id': f'exploit/edb/{edb_id}',
                        'module_path': item.get('Path', ''),
                        'title': item.get('Title', 'Unknown'),
                        'description': f"Exploit-DB #{edb_id}: {item.get('Title', 'Unknown')}",
                        'exploit_type': item.get('Type', 'unknown'),
                        'target_platform': item.get('Platform', 'unknown'),
                        'rank': 'normal',
                        'verified': False,
                        'exploit_db_id': edb_id,
                        'reference_url': f'https://www.exploit-db.com/exploits/{edb_id}' if edb_id else None
                    }
                    
                    exploits.append(exploit)
                    
                except Exception as e:
                    logger.error(f"Error parsing exploit item: {str(e)}")
                    continue
        
        return exploits
    
    async def update_database(self) -> bool:
        """
        Update the local Exploit-DB database
        
        Returns:
            True if update was successful, False otherwise
        """
        if not await self.is_available():
            logger.warning("searchsploit not available, cannot update database")
            return False
        
        try:
            logger.info("Updating Exploit-DB database...")
            process = await asyncio.create_subprocess_exec(
                'searchsploit', '-u',
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate()
            
            if process.returncode == 0:
                logger.info("Exploit-DB database updated successfully")
                return True
            else:
                logger.warning(f"Failed to update Exploit-DB database: {stderr.decode()}")
                return False
        
        except Exception as e:
            logger.error(f"Error updating Exploit-DB database: {str(e)}")
            return False
