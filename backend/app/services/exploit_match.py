"""
Exploit Match Service for CVE-to-exploit mappings
"""

import json
import logging
from typing import Dict, Any, List, Optional
from pathlib import Path
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from app.models.exploit_module import ExploitModule
from app.services.exploitdb_service import ExploitDBService

logger = logging.getLogger(__name__)


class ExploitMatchService:
    """Service for matching CVEs to exploit modules"""
    
    def __init__(self, db: AsyncSession):
        self.db = db
        self._static_mappings: Optional[Dict[str, List[Dict]]] = None
        self._exploitdb_service = ExploitDBService()
        self._exploitdb_cache: Dict[str, List[Dict[str, Any]]] = {}
    
    async def get_exploits_for_cve(self, cve_id: str) -> List[Dict[str, Any]]:
        """
        Get available exploit modules for a CVE
        
        Priority order:
        1. Exploit-DB (searchsploit) - dynamic lookup
        2. Database - stored exploit modules
        3. Static mappings - fallback CVE-to-exploit JSON
        
        Args:
            cve_id: CVE identifier (e.g., CVE-2023-1234)
            
        Returns:
            List of exploit module dicts
        """
        exploits = []
        existing_ids = set()
        
        try:
            # 1. Try Exploit-DB first (most up-to-date)
            exploitdb_exploits = await self._query_exploitdb(cve_id)
            for exploit in exploitdb_exploits:
                module_id = exploit.get("module_id")
                if module_id not in existing_ids:
                    exploits.append(exploit)
                    existing_ids.add(module_id)
            
            # 2. Query database
            db_exploits = await self._query_database(cve_id)
            for exploit in db_exploits:
                module_id = exploit.get("module_id")
                if module_id not in existing_ids:
                    exploits.append(exploit)
                    existing_ids.add(module_id)
            
            # 3. Check static mappings (fallback)
            static_exploits = await self._query_static_mappings(cve_id)
            for exploit in static_exploits:
                module_id = exploit.get("module_id")
                if module_id not in existing_ids:
                    exploits.append(exploit)
                    existing_ids.add(module_id)
            
            logger.info(f"Found {len(exploits)} exploits for {cve_id} (ExploitDB: {len(exploitdb_exploits)}, DB: {len(db_exploits)}, Static: {len(static_exploits)})")
            
        except Exception as e:
            logger.error(f"Error getting exploits for {cve_id}: {str(e)}")
        
        return exploits
    
    async def _query_exploitdb(self, cve_id: str) -> List[Dict[str, Any]]:
        """Query Exploit-DB using searchsploit with caching"""
        try:
            # Check cache first
            if cve_id in self._exploitdb_cache:
                logger.debug(f"Using cached Exploit-DB results for {cve_id}")
                return self._exploitdb_cache[cve_id]
            
            # Query Exploit-DB
            exploits = await self._exploitdb_service.search_by_cve(cve_id)
            
            # Cache results
            self._exploitdb_cache[cve_id] = exploits
            
            return exploits
            
        except Exception as e:
            logger.error(f"Error querying Exploit-DB for {cve_id}: {str(e)}")
            return []
    
    async def _query_database(self, cve_id: str) -> List[Dict[str, Any]]:
        """Query exploit modules from database"""
        try:
            result = await self.db.execute(
                select(ExploitModule).where(ExploitModule.cve_id == cve_id)
            )
            modules = result.scalars().all()
            
            return [self._module_to_dict(m) for m in modules]
            
        except Exception as e:
            logger.error(f"Error querying database for {cve_id}: {str(e)}")
            return []
    
    async def _query_static_mappings(self, cve_id: str) -> List[Dict[str, Any]]:
        """Query static CVE-to-exploit mappings"""
        try:
            # Load static mappings if not already loaded
            if self._static_mappings is None:
                await self._load_static_mappings()
            
            # Lookup CVE
            if self._static_mappings and cve_id in self._static_mappings:
                # Add required fields to static mappings
                exploits = []
                for idx, exploit in enumerate(self._static_mappings[cve_id]):
                    exploit_with_id = exploit.copy()
                    exploit_with_id["id"] = f"{cve_id}-{idx}"
                    exploit_with_id["cve_id"] = cve_id
                    exploits.append(exploit_with_id)
                return exploits
            
            return []
            
        except Exception as e:
            logger.error(f"Error querying static mappings for {cve_id}: {str(e)}")
            return []
    
    async def _load_static_mappings(self):
        """Load static CVE-to-exploit mappings from JSON file"""
        try:
            # Path to static mappings file
            mappings_file = Path(__file__).parent.parent / "data" / "cve_to_exploits.json"
            
            if not mappings_file.exists():
                logger.warning(f"Static mappings file not found: {mappings_file}")
                self._static_mappings = {}
                return
            
            with open(mappings_file, "r") as f:
                self._static_mappings = json.load(f)
            
            logger.info(f"Loaded {len(self._static_mappings)} static CVE mappings")
            
        except Exception as e:
            logger.error(f"Error loading static mappings: {str(e)}")
            self._static_mappings = {}
    
    def _module_to_dict(self, module: ExploitModule) -> Dict[str, Any]:
        """Convert ExploitModule to dict"""
        return {
            "id": str(module.id),
            "cve_id": module.cve_id,
            "platform": module.platform,
            "module_id": module.module_id,
            "module_path": module.module_path,
            "title": module.title,
            "description": module.description,
            "exploit_type": module.exploit_type,
            "target_platform": module.target_platform,
            "rank": module.rank,
            "verified": module.verified,
            "exploit_db_id": module.exploit_db_id,
            "reference_url": module.reference_url
        }
