"""
Exploit Match Service for CVE-to-exploit mappings
"""

import json
import logging
from typing import Dict, Any, List, Optional
from pathlib import Path
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from app.models.exploit_module import ExploitModule
from app.services.exploitdb_service import ExploitDBService

logger = logging.getLogger(__name__)


class ExploitMatchService:
    """Service for matching CVEs to exploit modules"""
    
    def __init__(self, db: AsyncSession):
        self.db = db
        self._static_mappings: Optional[Dict[str, List[Dict]]] = None
        self._exploitdb_service = ExploitDBService()
        self._exploitdb_cache: Dict[str, List[Dict[str, Any]]] = {}
    
    async def get_exploits_for_cve(self, cve_id: str) -> List[Dict[str, Any]]:
        """
        Get available exploit modules for a CVE
        
        Priority order:
        1. Exploit-DB (searchsploit) - dynamic lookup
        2. Database - stored exploit modules
        3. Static mappings - fallback CVE-to-exploit JSON
        
        Enrichment: Metadata from static mappings is merged into ExploitDB/DB results
        
        Args:
            cve_id: CVE identifier (e.g., CVE-2023-1234)
            
        Returns:
            List of exploit module dicts
        """
        exploits = []
        existing_ids = set()
        
        try:
            # Load static mappings first for metadata enrichment
            static_exploits = await self._query_static_mappings(cve_id)
            static_by_module = {e.get("module_path") or e.get("module_id"): e for e in static_exploits}
            
            # 1. Try Exploit-DB first (most up-to-date)
            exploitdb_exploits = await self._query_exploitdb(cve_id)
            for exploit in exploitdb_exploits:
                module_id = exploit.get("module_id")
                if module_id not in existing_ids:
                    # Enrich with static metadata if available
                    self._enrich_with_static_metadata(exploit, static_by_module)
                    exploits.append(exploit)
                    existing_ids.add(module_id)
            
            # 2. Query database
            db_exploits = await self._query_database(cve_id)
            for exploit in db_exploits:
                module_id = exploit.get("module_id")
                if module_id not in existing_ids:
                    # Enrich with static metadata if available
                    self._enrich_with_static_metadata(exploit, static_by_module)
                    exploits.append(exploit)
                    existing_ids.add(module_id)
            
            # 3. Add static mappings not already included
            for exploit in static_exploits:
                module_id = exploit.get("module_id")
                if module_id not in existing_ids:
                    exploits.append(exploit)
                    existing_ids.add(module_id)
            
            logger.info(f"Found {len(exploits)} exploits for {cve_id} (ExploitDB: {len(exploitdb_exploits)}, DB: {len(db_exploits)}, Static: {len(static_exploits)})")
            
        except Exception as e:
            logger.error(f"Error getting exploits for {cve_id}: {str(e)}")
        
        return exploits
    
    def _enrich_with_static_metadata(self, exploit: Dict[str, Any], static_by_module: Dict[str, Dict]) -> None:
        """Enrich exploit with metadata from static mappings"""
        # Try exact module_id/module_path match first
        module_key = exploit.get("module_path") or exploit.get("module_id")
        static = static_by_module.get(module_key) if module_key else None
        
        # If no exact match, try fuzzy match by title
        if not static:
            exploit_title = exploit.get("title", "").lower()
            logger.debug(f"Trying fuzzy match for: {exploit_title}")
            for static_exploit in static_by_module.values():
                static_title = static_exploit.get("title", "").lower()
                # Match if key terms overlap (vsftpd, backdoor, etc.)
                if self._titles_match(exploit_title, static_title):
                    static = static_exploit
                    logger.info(f"Fuzzy matched '{exploit_title}' with '{static_title}'")
                    break
        
        if not static:
            logger.debug(f"No static mapping found for {exploit.get('module_id')}")
            return
        
        # Merge exploit_metadata from static mapping
        if "exploit_metadata" in static and static["exploit_metadata"]:
            exploit["exploit_metadata"] = static["exploit_metadata"]
            logger.info(f"Enriched {exploit.get('module_id')} with static metadata (shell_port={static['exploit_metadata'].get('shell_port')})")
    
    def _titles_match(self, title1: str, title2: str) -> bool:
        """Check if two exploit titles refer to the same vulnerability"""
        # Extract key terms (ignore common words)
        def extract_key_terms(title: str) -> set:
            words = title.lower().split()
            stopwords = {'the', 'a', 'an', 'and', 'or', 'for', 'to', 'in', 'on', 'at', '-', 'command', 'execution', 'exploit', 'remote', 'local'}
            return {w for w in words if w not in stopwords and len(w) > 2}
        
        terms1 = extract_key_terms(title1)
        terms2 = extract_key_terms(title2)
        
        # Consider match if at least 2 key terms overlap
        overlap = terms1 & terms2
        return len(overlap) >= 2
    
    async def _query_exploitdb(self, cve_id: str) -> List[Dict[str, Any]]:
        """Query Exploit-DB using searchsploit with caching"""
        try:
            # Check cache first
            if cve_id in self._exploitdb_cache:
                logger.debug(f"Using cached Exploit-DB results for {cve_id}")
                return self._exploitdb_cache[cve_id]
            
            # Query Exploit-DB
            exploits = await self._exploitdb_service.search_by_cve(cve_id)
            
            # Cache results
            self._exploitdb_cache[cve_id] = exploits
            
            return exploits
            
        except Exception as e:
            logger.error(f"Error querying Exploit-DB for {cve_id}: {str(e)}")
            return []
    
    async def _query_database(self, cve_id: str) -> List[Dict[str, Any]]:
        """Query exploit modules from database"""
        try:
            result = await self.db.execute(
                select(ExploitModule).where(ExploitModule.cve_id == cve_id)
            )
            modules = result.scalars().all()
            
            return [self._module_to_dict(m) for m in modules]
            
        except Exception as e:
            logger.error(f"Error querying database for {cve_id}: {str(e)}")
            return []
    
    async def _query_static_mappings(self, cve_id: str) -> List[Dict[str, Any]]:
        """Query static CVE-to-exploit mappings"""
        try:
            # Load static mappings if not already loaded
            if self._static_mappings is None:
                await self._load_static_mappings()
            
            # Lookup CVE
            if self._static_mappings and cve_id in self._static_mappings:
                # Add required fields to static mappings
                exploits = []
                for idx, exploit in enumerate(self._static_mappings[cve_id]):
                    exploit_with_id = exploit.copy()
                    exploit_with_id["id"] = f"{cve_id}-{idx}"
                    exploit_with_id["cve_id"] = cve_id
                    exploits.append(exploit_with_id)
                logger.debug(f"Found {len(exploits)} static mappings for {cve_id}")
                return exploits
            else:
                logger.debug(f"No static mappings found for {cve_id} (loaded={self._static_mappings is not None}, exists={cve_id in (self._static_mappings or {})})")
            
            return []
            
        except Exception as e:
            logger.error(f"Error querying static mappings for {cve_id}: {str(e)}")
            return []
    
    async def _load_static_mappings(self):
        """Load static CVE-to-exploit mappings from JSON file"""
        try:
            # Path to static mappings file
            mappings_file = Path(__file__).parent.parent / "data" / "cve_to_exploits.json"
            
            if not mappings_file.exists():
                logger.warning(f"Static mappings file not found: {mappings_file}")
                self._static_mappings = {}
                return
            
            with open(mappings_file, "r") as f:
                self._static_mappings = json.load(f)
            
            logger.info(f"Loaded {len(self._static_mappings)} static CVE mappings")
            
        except Exception as e:
            logger.error(f"Error loading static mappings: {str(e)}")
            self._static_mappings = {}
    
    def _module_to_dict(self, module: ExploitModule) -> Dict[str, Any]:
        """Convert ExploitModule to dict"""
        return {
            "id": str(module.id),
            "cve_id": module.cve_id,
            "platform": module.platform,
            "module_id": module.module_id,
            "module_path": module.module_path,
            "title": module.title,
            "description": module.description,
            "exploit_type": module.exploit_type,
            "target_platform": module.target_platform,
            "rank": module.rank,
            "verified": module.verified,
            "exploit_db_id": module.exploit_db_id,
            "reference_url": module.reference_url,
            "exploit_metadata": None  # Database modules don't have metadata yet
        }
