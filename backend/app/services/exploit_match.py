"""
Exploit Match Service for CVE-to-exploit mappings
"""

import json
import logging
from typing import Dict, Any, List, Optional
from pathlib import Path
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from app.models.exploit_module import ExploitModule

logger = logging.getLogger(__name__)


class ExploitMatchService:
    """Service for matching CVEs to exploit modules"""
    
    def __init__(self, db: AsyncSession):
        self.db = db
        self._static_mappings: Optional[Dict[str, List[Dict]]] = None
    
    async def get_exploits_for_cve(self, cve_id: str) -> List[Dict[str, Any]]:
        """
        Get available exploit modules for a CVE
        
        Args:
            cve_id: CVE identifier (e.g., CVE-2023-1234)
            
        Returns:
            List of exploit module dicts
        """
        exploits = []
        
        try:
            # 1. Query database
            db_exploits = await self._query_database(cve_id)
            exploits.extend(db_exploits)
            
            # 2. Check static mappings
            static_exploits = await self._query_static_mappings(cve_id)
            
            # Merge, avoiding duplicates
            existing_ids = {e.get("module_id") for e in exploits}
            for exploit in static_exploits:
                if exploit.get("module_id") not in existing_ids:
                    exploits.append(exploit)
            
            logger.info(f"Found {len(exploits)} exploits for {cve_id}")
            
        except Exception as e:
            logger.error(f"Error getting exploits for {cve_id}: {str(e)}")
        
        return exploits
    
    async def _query_database(self, cve_id: str) -> List[Dict[str, Any]]:
        """Query exploit modules from database"""
        try:
            result = await self.db.execute(
                select(ExploitModule).where(ExploitModule.cve_id == cve_id)
            )
            modules = result.scalars().all()
            
            return [self._module_to_dict(m) for m in modules]
            
        except Exception as e:
            logger.error(f"Error querying database for {cve_id}: {str(e)}")
            return []
    
    async def _query_static_mappings(self, cve_id: str) -> List[Dict[str, Any]]:
        """Query static CVE-to-exploit mappings"""
        try:
            # Load static mappings if not already loaded
            if self._static_mappings is None:
                await self._load_static_mappings()
            
            # Lookup CVE
            if self._static_mappings and cve_id in self._static_mappings:
                # Add required fields to static mappings
                exploits = []
                for idx, exploit in enumerate(self._static_mappings[cve_id]):
                    exploit_with_id = exploit.copy()
                    exploit_with_id["id"] = f"{cve_id}-{idx}"
                    exploit_with_id["cve_id"] = cve_id
                    exploits.append(exploit_with_id)
                return exploits
            
            return []
            
        except Exception as e:
            logger.error(f"Error querying static mappings for {cve_id}: {str(e)}")
            return []
    
    async def _load_static_mappings(self):
        """Load static CVE-to-exploit mappings from JSON file"""
        try:
            # Path to static mappings file
            mappings_file = Path(__file__).parent.parent / "data" / "cve_to_exploits.json"
            
            if not mappings_file.exists():
                logger.warning(f"Static mappings file not found: {mappings_file}")
                self._static_mappings = {}
                return
            
            with open(mappings_file, "r") as f:
                self._static_mappings = json.load(f)
            
            logger.info(f"Loaded {len(self._static_mappings)} static CVE mappings")
            
        except Exception as e:
            logger.error(f"Error loading static mappings: {str(e)}")
            self._static_mappings = {}
    
    def _module_to_dict(self, module: ExploitModule) -> Dict[str, Any]:
        """Convert ExploitModule to dict"""
        return {
            "id": str(module.id),
            "cve_id": module.cve_id,
            "platform": module.platform,
            "module_id": module.module_id,
            "module_path": module.module_path,
            "title": module.title,
            "description": module.description,
            "exploit_type": module.exploit_type,
            "target_platform": module.target_platform,
            "rank": module.rank,
            "verified": module.verified,
            "exploit_db_id": module.exploit_db_id,
            "reference_url": module.reference_url
        }
